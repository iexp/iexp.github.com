<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>CVE-2010-0232漏洞分析 - Kernel Hack</title> 
  <meta name="description" content="Kernel Hack - OS Kernel Exploit">
  <meta name="author" content="iexp">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/disqus.css">

  <script src="/js/libs/modernizr-2.0.6.min.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
</head>

<body>
  <div id="container">	  

    <header>
  <h1><a class="fadedlink" href="/" title="首页">&laquo;</a> CVE-2010-0232漏洞分析 <small>2012-03-04</small></h1>

  <nav>
    <ul class="clearfix">
    
      <li><a href="/tags/CVE-2010-0232.html">CVE-2010-0232</a></li>
    
      <li><a href="/tags/POC.html">POC</a></li>
    
    </ul>
  </nav>
</header>

<script>
// https://github.com/ghiculescu/jekyll-table-of-contents
$(document).ready(function() {
  var no_back_to_top_links = false

  var headers = $('h1, h2, h3, h4, h5, h6').filter(function() {return this.id}), // get all headers with an ID
      output = $('.toc');
  if (!headers.length || headers.length < 3 || !output.length)
    return;

  var get_level = function(ele) { return parseInt(ele.nodeName.replace("H", ""), 10) }
  var highest_level = headers.map(function(_, ele) { return get_level(ele) }).get().sort()[0]
  // var return_to_top = '<i class="icon-arrow-up back-to-top"> ^ </i>'
  var return_to_top = ''

  var level = get_level(headers[0]), this_level, html = "<i></i> <ol>";
  headers.on('click', function() {
    if (!no_back_to_top_links) window.location.hash = this.id
  }).addClass('clickable-header').each(function(_, header) {
    this_level = get_level(header);
    if (!no_back_to_top_links && this_level === highest_level) {
      $(header).addClass('top-level-header').after(return_to_top)
    }
    if (this_level === level) // same level as before; same indenting
      html += "<li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    else if (this_level < level) // higher level than before; end parent ol
      html += "</li></ol></li><li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    else if (this_level > level) // lower level than before; expand the previous to contain a ol
      html += "<ol><li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    level = this_level; // update for the next one
  });
  html += "</ol>";
  if (!no_back_to_top_links) {
    $(document).on('click', '.back-to-top', function() {
      $(window).scrollTop(0)
      window.location.hash = ''
    })
  }
  output.hide().html(html).show('slow');
});
</script>
<div class="toc"></div>


<hr/>

<div id="post" role="main">
  <h1 id="">漏洞描述:</h1>

<p>在16位应用程序中，为了支持bios 服务例程，windows nt内核支持 virtual-8086模式下的bios调用的概念。在v86模式下内核通过触发一个#GP异常来实现bios调用，在KiTrap0d（#GP通用保护异常处理函数)内, 当KTRAP_FRAME.SegCs 等于0x0B 且 KTRAP_FRAME.Eip 等于Ki386BiosCallReturnAddress时，会跳到Ki386BiosCallReturnAddress函数， 此函数会使用KTRAP_FRAME.ESI作为栈指针进行堆栈操作，但是没有进行合法性检查，当KTRAP_FRAME.ESI的值可以被我们控制时，会造成以ring0 权限执行任意代码。此漏洞通过VDM伪造Trap Frame, 在iret 执行时 ，触发#GP异常 进而触发漏洞。</p>

<p>为了绕过检查最终触发漏洞，需要解决以下3点：</p>

<ul>
<li>设置TEB-&gt;Vdm-&gt;Conext需要SeTcbPrivilege权限。</li>

<li>ring 3下，不能设置cs为任意值。</li>

<li>ring 3下，不能伪造Trap Frame.</li>
</ul>

<p>在NtVdmControl系统服务中，创建一个VDM conext需要设置EPROCESS-&gt;Flags.VdmAllowed。VdmAllowed仅可以通过NtSetInformationProcess设置，此函数会检查调用者是否具有 SeTcbPrivilege权限，通过建立一个ntvdm子系统，然后使用CreateRemoteThread在子系统上下文环境下执行一个线程，此标志会被设置，可以解决第一点。</p>

<p>cpl通常为cs和ss的低两位，表示当前任务的特权级。而在Virtual-8086模式下cs用来进行寻址操作，因此在V86模式下，可以设置cpl为任意值。</p>

<p>通过iret返回到用户模式，需要两个阶段，分为 pre-mommit和post-commit两个阶段。 可以通过NTVdmControl来设置一个Vdm Conext, 通过设置context的flags.TF位，使 pre-commit失败，因此可以伪造一个陷阱帧。</p>

<h1 id="_2">漏洞分析:</h1>

<p>当执行NtVdmControl(VdmStartExecution, NULL)时 , NtVdmControl –&gt; nt!VdmpStartExecution， 会调用 nt!VdmpGetVdmTib来获取VdmTib,并检查我们的VdmTib.Size (TEB-&gt;Vdm);</p>

<pre><code>kd&gt; uf nt!VdmpGetVdmTib
nt!VdmpGetVdmTib:
80980bd8 6a18            push    18h
80980bda 6890a78080      push    offset nt!`string&#39;+0xfc8 (8080a790)
80980bdf e8d03fefff      call    nt!__SEH_prolog (80874bb4)
80980be4 33d2            xor     edx,edx
80980be6 8955e4          mov     dword ptr [ebp-1Ch],edx
80980be9 8955fc          mov     dword ptr [ebp-4],edx
80980bec 64a118000000    mov     eax,dword ptr fs:[00000018h]          ; _KPCR-&gt;_NT_TIB-&gt;Self指向用户层的TEB
80980bf2 8b80180f0000    mov     eax,dword ptr [eax+0F18h]             ; _TEB-&gt;Vdm
80980bf8 8945e0          mov     dword ptr [ebp-20h],eax               ; 保存起来
80980bfb 3bc2            cmp     eax,edx                        
80980bfd 7509            jne     nt!VdmpGetVdmTib+0x30 (80980c08)

nt!VdmpGetVdmTib+0x27:
80980bff c745e4010000c0  mov     dword ptr [ebp-1Ch],0C0000001h
80980c06 eb31            jmp     nt!VdmpGetVdmTib+0x61 (80980c39)

nt!VdmpGetVdmTib+0x30:
80980c08 8945d8          mov     dword ptr [ebp-28h],eax
80980c0b 8b0d98e28880    mov     ecx,dword ptr [nt!MmUserProbeAddress (8088e298)]
80980c11 3bc1            cmp     eax,ecx                              ; 测试_TEB-&gt;VDM是否为用户层地址
80980c13 7202            jb      nt!VdmpGetVdmTib+0x3f (80980c17)

nt!VdmpGetVdmTib+0x3d:
80980c15 8811            mov     byte ptr [ecx],dl

nt!VdmpGetVdmTib+0x3f:
80980c17 8a08            mov     cl,byte ptr [eax]                    ; 如果Vdm地址合法，跳到这里
80980c19 8808            mov     byte ptr [eax],cl
80980c1b 8d8877060000    lea     ecx,[eax+677h]
80980c21 8a19            mov     bl,byte ptr [ecx]                    ; 这两条指令测试读写内存是否合法
80980c23 8819            mov     byte ptr [ecx],bl                    ;
80980c25 813878060000    cmp     dword ptr [eax],678h                 ; 这里检查VdmTib.Size
80980c2b 740c            je      nt!VdmpGetVdmTib+0x61 (80980c39)

nt!VdmpGetVdmTib+0x55:
80980c2d c745e4010000c0  mov     dword ptr [ebp-1Ch],0C0000001h
80980c34 33c0            xor     eax,eax
80980c36 8945e0          mov     dword ptr [ebp-20h],eax

nt!VdmpGetVdmTib+0x61:
80980c39 834dfcff        or      dword ptr [ebp-4],0FFFFFFFFh
80980c3d 8b4d08          mov     ecx,dword ptr [ebp+8]
80980c40 8901            mov     dword ptr [ecx],eax                  ; 将VdmTib的地址存放到第一个参数指向的地址处
80980c42 8b45e4          mov     eax,dword ptr [ebp-1Ch]              ; 返回值
80980c45 eb18            jmp     nt!VdmpGetVdmTib+0x87 (80980c5f)

nt!VdmpGetVdmTib+0x87:
80980c5f e88b3fefff      call    nt!__SEH_epilog (80874bef)
80980c64 c20400          ret     4</code></pre>

<p><a href="http://doxygen.reactos.org/dd/de7/vdm_8h_source.html">Thread Information Block for VDMThreads</a></p>

<pre><code>typedef struct _Vdm_Tib {
ULONG Size;                 // 会在nt!VdmpGetVdmTib中检查
PVDM_INTERRUPTHANDLER VdmInterruptTable;
PVDM_FAULTHANDLER VdmFaultTable;
CONTEXT MonitorContext;
CONTEXT VdmContext;         // 会在后面用到
VDMEVENTINFO EventInfo;
VDM_PRINTER_INFO PrinterInfo;
ULONG TempArea1[2];
ULONG TempArea2[2];
VDMTRACEINFO TraceInfo;
ULONG IntelMSW;
LONG NumTasks;
PFAMILY_TABLE *pDpmFamTbls;
BOOLEAN ContinueExecution;
} VdmTib = {0};</code></pre>

<p>TEB-&gt;Vdm 这里可以设置我们自己构造的VDM_TIB结构体</p>

<pre><code> *NtCurrentTeb()-&gt;Reserved4 =&amp;VdmTib;   </code></pre>

<p>之后nt!VdmpStartExecution 会调用 nt!VdmSwapContexts。而在nt!VdmSwapContexts函数中会修改KiFastCallEntry创建的陷阱帧(trap frame)。将trap frame修改为我们的VdmTib.VdmContext， 见以下代码实现：</p>

<pre><code>nt!VdmSwapContexts(PKTRAP_FRAME TrapFrame,PCONTEXT MonitorContext, PCONTEXT VdmContext) {
TrapFrame-&gt;SegCs = VdmContext-&gt;SegCs;
TrapFrame-&gt;HardwareSegSs = VdmContext-&gt;SegSs;
TrapFrame-&gt;Eax = VdmContext-&gt;Eax;
TrapFrame-&gt;Ebx = VdmContext-&gt;Ebx;
TrapFrame-&gt;Ecx = VdmContext-&gt;Ecx;
TrapFrame-&gt;Edx = VdmContext-&gt;Edx;
TrapFrame-&gt;Esi = VdmContext-&gt;Esi;
TrapFrame-&gt;Edi = VdmContext-&gt;Edi;
TrapFrame-&gt;Ebp = VdmContext-&gt;Ebp;
TrapFrame-&gt;HardwareEsp = VdmContext-&gt;Esp;
TrapFrame-&gt;Eip = VdmContext-&gt;Eip;

TrapFrame-&gt;SegCs |= RPL_MASK;
TrapFrame-&gt;HardwareSegSs |= RPL_MASK;
  /*Check for bogus CS */
  if(TrapFrame-&gt;SegCs &lt; KGDT_R0_CODE) {
   /* Set user-mode */
   TrapFrame-&gt;SegCs = KGDT_R3_CODE | RPL_MASK;
  }
}</code></pre>

<p>因此trap frame可以被我们控制，在返回ring3时会调用 iret指令。</p>

<p>根据intel手册，可知：<br />在cpu执行iret过程中，EFLAG寄存器的TF和VM标志位可影响执行结果， 当vm=1时将在v86模式下创建任务，当tf=1时，可引发 #GP异常。</p>

<p>设置如下，会导致一个#GP异常:<br />VdmTib.VdmContext.EFlags = EFLAGS_TF_MASK;</p>

<p>当#GP异常发生时，CPU运行在RING0，且此时堆栈并没有切换（因为没有进行特权级切换），即陷阱帧保持不变。</p>

<p>在KiTrap0d（#GP通用保护异常处理函数)内:</p>

<pre><code>nt!KiTrap0D+0x22f:
8053ff8f b842015080 mov    eax,offset nt!Ki386BiosCallReturnAddress(80500142)
8053ff94 3b02       cmp    eax,dword ptr [edx]              ; edx = KTRAP_FRAME.Eip  (VdmContext-&gt;eip)
8053ff96 750e       jne    nt!KiTrap0D+0x246 (8053ffa6)
8053ff98 8b4204     mov    eax,dword ptr [edx+4]            ; edx+4 = KTRAP_FRAME.SegCs  (VdmContext-&gt;SegCs)
8053ff9b 6683f80b   cmp    ax,0Bh
8053ff9f 7505       jne    nt!KiTrap0D+0x246 (8053ffa6)
8053ffa1 e99c01fcff jmp    nt!Ki386BiosCallReturnAddress (80500142)</code></pre>

<p>由上代码可知：只要构造如下，执行流程就会跳到Ki386BiosCallReturnAddress:<br />Tib.VdmContext.SegCs = 0x0B;<br />Tib.VdmContext.Eip = Ki386BiosCallReturnAddress;</p>

<p>当执行到Ki386BiosCallReturnAddress, 见 下面代码分析:</p>

<pre><code>Ki386BiosCallReturnAddress
.text:0043C3CE Ki386BiosCallReturnAddressproc near
.text:0043C3CE     mov    eax, large fs:KPCR.SelfPcr                            ; kpcr[SelfPcr] 指向_KPCR
.text:0043C3D4     mov    edi, [ebp+KTRAP_FRAME.Esi]
.text:0043C3D7     mov    edi, [edi]
.text:0043C3D9     mov    esi, [eax+KPCR.NtTib.StackBase]                       ; esi指向_NT_TIB.StackBase
.text:0043C3DC     mov    ecx, 84h
.text:0043C3E1     mov    [eax+KPCR.NtTib.StackBase], edi
.text:0043C3E4     rep    movsd
.text:0043C3E6     mov    esp, [ebp+KTRAP_FRAME.Esi]                            ; 此时esp指向trap fram的esi,即VdmContext-&gt;Esi
.text:0043C3E9     add    esp, 4                                                ; esp+4
.text:0043C3EC     mov    ecx, [eax+KPCR.PrcbData.CurrentThread]
;_KPCR.PrcbData.CurrentThread (KTHREAD)

.text:0043C3F2     mov    [ecx+KTHREAD.InitialStack], edi      
;_KTHREAD.InitialStack = _NT_TIB.StackBase

.text:0043C3F5     mov    eax, [eax+KPCR.TSS]
.text:0043C3F8     sub    edi, 220h
.text:0043C3FE     mov    [eax+KTSS.Esp0], edi
.text:0043C401     pop    edx                                                   ; esp+4
.text:0043C402     mov    [ecx+KTHREAD.Teb], edx
.text:0043C405     pop    edx                                                   ; esp+4
.text:0043C406     mov    large fs:KPCR.NtTib.Self, edx
.text:0043C40D     mov    ebx, large fs:KPCR.GDT
.text:0043C414     mov    [ebx+3Ah], dx
.text:0043C418     shr    edx, 10h
.text:0043C41B     mov    byte ptr [ebx+3Ch], dl
.text:0043C41E     mov    [ebx+3Fh], dh
.text:0043C421     sti
.text:0043C422     pop    edi                                                   ; esp+4
.text:0043C423     pop    esi                                                   ; esp+4
.text:0043C424     pop    ebx                                                   ; esp+4
.text:0043C425     pop    ebp                                                   ; esp+4
.text:0043C426     retn   4
</code></pre>

<p>由以上代码可知： 当Tib.VdmContext.Esi 指向 如下所示伪造的栈时， Ki386BiosCallReturnAddress返回时， 会跳到被我们控制的eip处，并且此时cpl=0，即特权级为0执行eip处的代码。</p>

<pre><code>KernelStack==&gt;  |  0  |   1  |  2 |  3  |  4  |  5  |  6  |  eip |
                             +4   +4   +4   +4   +4  +4  +4</code></pre>

<p><a href="http://lists.grok.org.uk/pipermail/full-disclosure/2010-January/072549.html">参考</a></p>
  <p class="back">&laquo; <a href="/">首页</a></p>
</div>

<!--
<h2>相关</h2>
<ul class="posts_list">
  
  <li class="post">
    <span class="date">2013-05-04</span> &raquo; <a href="/2013/05/04/CVE-2011-2018-vul" title="CVE-2011-2018漏洞分析">CVE-2011-2018漏洞分析</a>
  </li>
  
  <li class="post">
    <span class="date">2013-01-07</span> &raquo; <a href="/2013/01/07/irql" title="关于IRQL问题的记录">关于IRQL问题的记录</a>
  </li>
  
</ul>
-->

<hr/>

<h2>留言</h2>
<div id="disqus_thread"></div> <!-- css 样式 -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'iexp'; // required: replace example with your forum shortname
    //var disqus_developer = 1; // developer mode is on, for testing locally

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    <footer>
      <span>iexp </span>
      <a href="/categories/tags.html">tags</a>
    </footer>
  </div>

  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->
</body>
</html>
