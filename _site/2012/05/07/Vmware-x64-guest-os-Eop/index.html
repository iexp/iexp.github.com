<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>CVE-2008-4279 漏洞分析 - Kernel Hack</title> 
  <meta name="description" content="Kernel Hack - OS Kernel Exploit">
  <meta name="author" content="iexp">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/disqus.css">

  <script src="/js/libs/modernizr-2.0.6.min.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
</head>

<body>
  <div id="container">	  

    <header>
  <h1><a class="fadedlink" href="/" title="首页">&laquo;</a> CVE-2008-4279 漏洞分析 <small>2012-05-07</small></h1>

  <nav>
    <ul class="clearfix">
    
      <li><a href="/tags/CVE-2008-4279.html">CVE-2008-4279</a></li>
    
      <li><a href="/tags/VMware.html">VMware</a></li>
    
      <li><a href="/tags/x64.html">x64</a></li>
    
      <li><a href="/tags/EOP.html">EOP</a></li>
    
    </ul>
  </nav>
</header>

<script>
// https://github.com/ghiculescu/jekyll-table-of-contents
$(document).ready(function() {
  var no_back_to_top_links = false

  var headers = $('h1, h2, h3, h4, h5, h6').filter(function() {return this.id}), // get all headers with an ID
      output = $('.toc');
  if (!headers.length || headers.length < 3 || !output.length)
    return;

  var get_level = function(ele) { return parseInt(ele.nodeName.replace("H", ""), 10) }
  var highest_level = headers.map(function(_, ele) { return get_level(ele) }).get().sort()[0]
  // var return_to_top = '<i class="icon-arrow-up back-to-top"> ^ </i>'
  var return_to_top = ''

  var level = get_level(headers[0]), this_level, html = "<i></i> <ol>";
  headers.on('click', function() {
    if (!no_back_to_top_links) window.location.hash = this.id
  }).addClass('clickable-header').each(function(_, header) {
    this_level = get_level(header);
    if (!no_back_to_top_links && this_level === highest_level) {
      $(header).addClass('top-level-header').after(return_to_top)
    }
    if (this_level === level) // same level as before; same indenting
      html += "<li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    else if (this_level < level) // higher level than before; end parent ol
      html += "</li></ol></li><li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    else if (this_level > level) // lower level than before; expand the previous to contain a ol
      html += "<ol><li><a href='#" + header.id + "'>" + header.innerHTML + "</a>";
    level = this_level; // update for the next one
  });
  html += "</ol>";
  if (!no_back_to_top_links) {
    $(document).on('click', '.back-to-top', function() {
      $(window).scrollTop(0)
      window.location.hash = ''
    })
  }
  output.hide().html(html).show('slow');
});
</script>
<div class="toc"></div>


<hr/>

<div id="post" role="main">
  <h1 id="">漏洞描述:</h1>

<p>在VMware x64 Guest OS中, 利用其模拟指令的缺陷可导致以ring 0权限执行任意代码。</p>

<h1 id="_2">漏洞分析:</h1>

<p>下面的伪汇编片断提供了一个 x64体系下中断处理函数的典型实现，结合Vmware的指令模拟缺陷可产生安全漏洞：</p>

<pre><code>
ISR_Entry_Point:

    ; For a long-mode (64-bit) ISR, RSP points to the following QWORDs:
    ;
    ;   [&lt;error code&gt;]
    ;   &lt;return RIP&gt; 
    ;   &lt;return CS&gt; 
    ;   &lt;return RFLAGS&gt;
    ;   [&lt;return RSP&gt; 
    ;   &lt;return SS&gt;]
    ;
    ; 一个典型的中断服务例程 首先会创建一个标准的陷阱帧。
    ; The first act of typical ISR prologue code is to build a standard
    ; &quot;trap frame&quot; on the stack -- saving registers, etc.

     ...                                        ; GS -&gt; user or kernel

    ; If the CPL at the time of the fault (recorded in the two least
    ; significant bits of &lt;return CS&gt;) was zero, then the fault occurred
    ; in kernel mode; some OSes then assume that kernel GS is already
    ; active, and will therefore skip the SWAPGS instruction.

    ; 这里测试发生异常时的cpl，如果为0，则不会进行GS切换
    TEST    [return CS], (1, 2, or 3)           ; GS -&gt; user or kernel
    JZ      Skip_Swap                           ; GS -&gt; user or kernel

    ; If the previous mode was user mode, then it is assumed that the
    ; user GS base address is loaded, so SWAPGS will exchange the
    ; value in the KernelGSbase MSR (MSR C000_0102h) with the base
    ; address in the GS shadow descriptor, in effect switching from
    ; user GS to kernel GS.

    ; 如果发生中断时的cpl不等于0，即位于user-mode，则进行GS切换
    SWAPGS                                     ; before: GS -&gt; user; after: GS -&gt; kernel

  Skip_Swap:

    ; Now it&#39;s (supposedly) safe to use GS: to access GS-relative kernel
    ; data structures.

    ; 到这里时，操作系统认为GS已经切换到kernel-mode了
     ...                                       ; GS -&gt; kernel

    ; At this point, the ISR switches back to user GS if returning to
    ; user mode; if returning to kernel mode, it leaves kernel GS loaded
    ; and therefore doesn&#39;t need to do SWAPGS.

    ; 这里进行测试cpl，如果之前模式为kernel模式，则跳过GS切换
    ; 否则 将GS切换为user-mode
    TEST    [return CS], (1, 2, or 3)          ; GS -&gt; kernel
    JZ      Skip_Swap_Back                     ; GS -&gt; kernel

    SWAPGS                                     ; before: GS -&gt; kernel; after: GS -&gt; user

  Skip_Swap_Back:

    IRETQ                                      ; GS -&gt; user or kernel</code></pre>

<p>由以上代码可知：</p>

<p>如果在异常处理函数的开始处第一个swapgs之前产生一个异常，那么跳入另一个异常处理函数后将不会进行GS切换，因为之前CPU模式为ring 0。如果进入第一个异常处理函数之前的CPU模式为user-mode,则会产生安全漏洞，因为此时CPU处于ring 0, 但gs还没有进行切换，位于user-mode。</p>

<p>同样在异常处理函数结尾，执行完swapgs之后发生异常，也会产生相同漏洞。 如果在用户模式下可以使内核在以上区域发生一个异常，将触发漏洞。 VMware模拟的指令可以在以上区域触发一个异常，可引发漏洞。</p>

<p><strong>Flaw #1</strong>(CVE-2008-4279):</p>

<p>x64体系定义规范(Canonical)地址的第48到63位必须是第47位的副本，否则为非规范地址，访问非规范（Non-Canonical）地址会触发#GP异常。</p>

<p>正常情况： jmp [xxx]，发生#GP时，TrapFrame的rip为发生异常时指令的地址。 但VMware 模拟的jmp [xxx] 间接跳转指令存在缺陷，发生#GP时，TrapFrame的rip为 jmp 的目标地址（即non-canonical地址)。</p>

<p>x64 Windows下的#GP异常，不会调用 iretq返回到user-mode的non-canonical地址,而是通过KiExceptionDispatch进行异常分发处理，返回到user-mode的ntdll的异常处理函数中。</p>

<p>尽管这样，当重复执行一个 jmp [non-canonical]时，最终将在non-canonical地址处产生一个硬件中断。这样在硬件中断处理函数处理完成执行iretq时，返回的rip为non-canonical地址，触发一个#GP异常， 由于此时已经将GS切换到user-mode，但CPU运行在ring 0，引发漏洞。</p>

<p><em>注意</em>： 此漏洞不会发生在开启了“禁用加速”的情况下。</p>

<p><a href="http://lists.grok.org.uk/pipermail/full-disclosure/2008-October/064860.html">参考</a></p>
  <p class="back">&laquo; <a href="/">首页</a></p>
</div>

<!--
<h2>相关</h2>
<ul class="posts_list">
  
  <li class="post">
    <span class="date">2013-05-04</span> &raquo; <a href="/2013/05/04/CVE-2011-2018-vul" title="CVE-2011-2018 漏洞分析">CVE-2011-2018 漏洞分析</a>
  </li>
  
  <li class="post">
    <span class="date">2013-01-07</span> &raquo; <a href="/2013/01/07/irql" title="关于IRQL问题的记录">关于IRQL问题的记录</a>
  </li>
  
  <li class="post">
    <span class="date">2012-03-04</span> &raquo; <a href="/2012/03/04/CVE-2010-0232-vul" title="CVE-2010-0232漏洞分析">CVE-2010-0232漏洞分析</a>
  </li>
  
</ul>
-->

<hr/>

<h2>留言</h2>
<div id="disqus_thread"></div> <!-- css 样式 -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'iexp'; // required: replace example with your forum shortname
    //var disqus_developer = 1; // developer mode is on, for testing locally

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    <footer>
      <span>iexp </span>
      <a href="/categories/tags.html">tags</a>
    </footer>
  </div>

  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->
</body>
</html>
